// This file was automatically generated by fhq-server (v0.2.25), date: 08 Jan 2020
import { Injectable, EventEmitter } from '@angular/core';
import { PlatformLocation } from '@angular/common';

declare var FreeHackQuestClientConfig: any;

@Injectable({providedIn: 'root'})
export class FreeHackQuestClient {
  private appName: string = 'fhq-server';
  private appVersion: string = '0.2.25';
  private appBuildDate: string = '08 Jan 2020';
  isAuthorized: boolean = false;
  connectionState: string = '';
  serverHost: string = 'localhost';
  currentProtocol: string = 'http:';
  private _tokenName: string = 'fhqtoken';
  userdata: any = {};
  changedState = new EventEmitter<any>();
  private _lastm: number = 0;
  private _listeners: any = {};
  private _connectionState: string = '?';
  private _tokenValue: string = '';
  private _socket: WebSocket = null;
  private _events: any = {
    'server': [],
    'notify': [],
    'chat': [],
    'connected': [],
    'reconnecting': [],
    'disconnected': [],
    'broken': [],
    'userdata': [],
  };
  private _lastConnectionParams: any = null;

  constructor(
    private _location: PlatformLocation,
  ) {
    this.serverHost = this._location.hostname;
    // this.serverHost = 'freehackquest.com';
    this.currentProtocol = this._location.protocol;
    console.warn('fhq (v0.2.25)');
    this._tokenValue = this.getToken();

    this.bind('server', ((response) => { 
        console.warn('All: ', response);
        if (response.app != this.appName) {
            console.error('FreeHackQuestClient, AppName: ' + response.app + ', but expected ' + this.appName);
        }
        if (response.version != this.appVersion) {
            console.error('FreeHackQuestClient, AppVersion: ' + response.version + ', but expected ' + this.appVersion);
        }
    }));
  }

  setToken(token: string) {
    var date = new Date( new Date().getTime() + (7 * 24 * 60 * 60 * 1000) ); // cookie on week
    document.cookie = this._tokenName + '=' + encodeURIComponent(token) + '; path=/; expires='+date.toUTCString();
  }
  
  removeToken() {
    this._tokenValue = '';
    document.cookie = this._tokenName + '=; path=/;';
  }

  getToken() {
    var matches = document.cookie.match(new RegExp(
      '(?:^|; )' + this._tokenName.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'
    ));
    return matches ? decodeURIComponent(matches[1]) : '';
  }

  bind(name: string, f: Function) {
    this._events[name].push(f);
  }

  unbind(name: string) {
    this._events[name] = [];
  }

  _call(name: string, data: any) {
    function __call(f: any, data: any) {
      setTimeout(function() { f(data) },1)
    }
    for (var i = 0; i < this._events[name].length; i++) {
      __call(this._events[name][i], data);
    }
  }

  private socketOnOpen() {
    console.log('FreeHackQuestClient WS Opened');
    this._call('connected', {});
    if (this._tokenValue != '') this.token();
  }

  private socketOnClose(event: any) {
    console.log('FreeHackQuestClient Closed');
    if (event.wasClean) {
        this._call('disconnected', {});
    } else {
        this._call('broken', {});
        setTimeout(function() {
            this._call('reconnecting', {});
            if (this._lastConnectionParams != null) {
                this.connectToServer(this._lastConnectionParams);
            }
        }, 10000);
        // Try reconnect after 10 sec
    }
    console.log('Code: ' + event.code + ' Reason: ' + event.reason);
  }

  private _socketOnMessage(event: any) {
    console.log('FreeHackQuestClient Received: ' + event.data);
    try {
        var response = JSON.parse(event.data);
        this._handleCommand(response);
    } catch(e) {
        console.error(e);
    }
  }

  private _socketOnError(error: any) {
    console.log('FreeHackQuestClient Socket Error: ', error);
  }

  connectToServer(initParams: any) {
    this._lastConnectionParams = null;
    if (!initParams.baseUrl) console.error('Expected baseUrl on initParams');
    this._lastConnectionParams = initParams;
    this._socket = new WebSocket(initParams.baseUrl);
    this._socket.onopen = (() => this.socketOnOpen());
    this._socket.onclose = ((event: any) => this.socketOnClose(event));
    this._socket.onmessage = ((event: any) => this._socketOnMessage(event));
    this._socket.onerror = ((error: any) => this._socketOnError(error));
  }

  private _lm() { this._lastm++; return 'm' + this._lastm; };

  send(obj: any, def: any = null) {
    obj.m = obj.m || this._lm();
    this._listeners[obj.m] = def || this.promise();
    try {
      if (this._socket.readyState == 0) {
        setTimeout(function() {
          this.send(obj, this._listeners[obj.m]);
        },1000);
      } else {
        this._socket.send(JSON.stringify(obj));
      }
    } catch(e) {
      console.error(e);
    }
    return this._listeners[obj.m];
  }
  
  promise() {
    return {
        completed: false, failed: false, successed: false, 
        done: function(callback) {
            this.done_callback = callback;
            if (this.completed && typeof this.done_callback === 'function' && this.successed) {
                this.done_callback.apply(this, this.result_arguments);
            }
            return this;
        },
        fail: function(callback) {
            this.fail_callback = callback;
            if (this.completed && typeof this.fail_callback === 'function' && this.failed) {
                this.fail_callback.apply(this, this.error_arguments);
            }
            return this;
        },
        resolve: function(result: any = null) {
            if (!this.completed) {
                this.result_arguments = arguments; // [];
                if (typeof this.done_callback === 'function') {
                    this.done_callback.apply(this, this.result_arguments);
                }
            }
            this.successed = true;
            this.completed = true;
        },
        reject: function(error: any = null) {
            if (!this.completed) {
                this.error_arguments = arguments;
                if (typeof this.fail_callback === 'function') {
                    this.fail_callback.apply(this, this.error_arguments);
                }
            }
            this.failed = true;
            this.completed = true;
        }
    }
  }
  private _handleCommand(response: any) {
    var lstn = this._listeners[response.m];
    if (lstn) {
        setTimeout(function() {
            if (response['error']) {
                lstn.reject(response);
            } else {
                lstn.resolve(response);
            }
            delete this._listeners[response.m];
        },1);
    } else if (this._events[response.cmd]) {
        this._call(response.cmd, response);
    } else {
        console.error('Not found handler for [' + response.cmd + '/' + response.m + ']');
    }
  };

  /*
    self.waitAllPromises = function(arr_promise) {
        var p = self.promise();
        var max_len = arr_promise.length;
        var result = [];
        function cmpl(r) {
            result.push(r);
            if (result.length == max_len) {
                p.resolve(result);
            }
        };
        for (var i in arr_promise) {
            arr_promise[i].done(cmpl).fail(cmpl);
        }
        return p;
    };

   
    
    self.deinit = function(initParams) {
       self.removeToken();
       self.socket.close();
    }
   self.userProfile = {bInitUserProfile: false}
     */

  token(params: any = null) {
      console.log("Params: ", params)
    // Access unauthorized: yes
    // Access user: no
    // Access admin: no
    // Input params:
    // * token - string, required (Authorization token) 
    params = params || {};
    params.cmd = 'token';
    if (params['token'] == undefined) {
        console.error('Parameter "token" expected (lib)');
    }
    if (this._tokenValue != '') {
        var ret = this.promise()
        params.token = this._tokenValue;
        this.send(params).done(function(r) {
            this.updateUserProfileAsync();
            ret.resolve(r);
        }).fail(function(err) {
            this.removeToken();
            this._call('userdata', {});
            ret.reject(err);
        })
        return ret;
    } else {
      return this.send(params);
    }
  }
}
